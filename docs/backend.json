{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the BizView application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user entity."
        },
        "name": {
          "type": "string",
          "description": "The user's full name."
        },
        "email": {
          "type": "string",
          "description": "The user's email address.",
          "format": "email"
        }
      },
      "required": [
        "id",
        "name",
        "email"
      ]
    },
    "Expense": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Expense",
      "type": "object",
      "description": "Represents an expense incurred by the business.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the expense entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Expense)"
        },
        "date": {
          "type": "string",
          "description": "The date the expense was incurred.",
          "format": "date-time"
        },
        "amount": {
          "type": "number",
          "description": "The amount of the expense."
        },
        "category": {
          "type": "string",
          "description": "The category of the expense (e.g., supplies, rent, utilities)."
        },
        "description": {
          "type": "string",
          "description": "A description of the expense."
        }
      },
      "required": [
        "id",
        "userId",
        "date",
        "amount",
        "category"
      ]
    },
    "Revenue": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Revenue",
      "type": "object",
      "description": "Represents a revenue stream for the business.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the revenue entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Revenue)"
        },
        "date": {
          "type": "string",
          "description": "The date the revenue was received.",
          "format": "date-time"
        },
        "amount": {
          "type": "number",
          "description": "The amount of the revenue."
        },
        "category": {
          "type": "string",
          "description": "The category of the revenue (e.g., sales, services)."
        },
        "description": {
          "type": "string",
          "description": "A description of the revenue."
        }
      },
      "required": [
        "id",
        "userId",
        "date",
        "amount",
        "category"
      ]
    },
    "Appointment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Appointment",
      "type": "object",
      "description": "Represents a scheduled appointment.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the appointment entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Appointment)"
        },
        "startTime": {
          "type": "string",
          "description": "The start time of the appointment.",
          "format": "date-time"
        },
        "endTime": {
          "type": "string",
          "description": "The end time of the appointment.",
          "format": "date-time"
        },
        "title": {
          "type": "string",
          "description": "The title of the appointment."
        },
        "description": {
          "type": "string",
          "description": "A description of the appointment."
        }
      },
      "required": [
        "id",
        "userId",
        "startTime",
        "endTime",
        "title"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. The 'userId' parameter represents the unique identifier for each user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/expenses/{expenseId}",
        "definition": {
          "entityName": "Expense",
          "schema": {
            "$ref": "#/backend/entities/Expense"
          },
          "description": "Stores expenses owned by a specific user. Path-based ownership enables secure list operations.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "expenseId",
              "description": "The unique identifier of the expense."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/revenues/{revenueId}",
        "definition": {
          "entityName": "Revenue",
          "schema": {
            "$ref": "#/backend/entities/Revenue"
          },
          "description": "Stores revenues owned by a specific user. Path-based ownership enables secure list operations.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "revenueId",
              "description": "The unique identifier of the revenue."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/appointments/{appointmentId}",
        "definition": {
          "entityName": "Appointment",
          "schema": {
            "$ref": "#/backend/entities/Appointment"
          },
          "description": "Stores appointments owned by a specific user. Path-based ownership enables secure list operations.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            },
            {
              "name": "appointmentId",
              "description": "The unique identifier of the appointment."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to address the \"Missing or insufficient permissions\" error by ensuring authorization independence and secure data access based on user ownership. The primary strategy is to use path-based ownership for user-related data, eliminating the need for `get()` calls in security rules and simplifying list operations.\n\n**Structure:**\n\n*   `/users/{userId}`: Stores user profiles.\n*   `/users/{userId}/expenses/{expenseId}`: Stores expenses owned by a specific user.\n*   `/users/{userId}/revenues/{revenueId}`: Stores revenues owned by a specific user.\n*   `/users/{userId}/appointments/{appointmentId}`: Stores appointments owned by a specific user.\n\n**Authorization Independence and QAPs:**\n\nThe structure achieves authorization independence by directly associating each data entity (expenses, revenues, appointments) with its owner via the path (`/users/{userId}`). This allows security rules to be written based solely on the `request.auth.uid` and the path, without needing to read data from other documents. Specifically:\n\n*   **Expenses, Revenues, and Appointments:** Since these are stored as subcollections of `/users/{userId}`, listing operations can be secured by checking if `request.auth.uid` matches the `{userId}` in the path. This prevents unauthorized listing of other users' data.\n\nThis design supports secure `list` operations (QAPs) because the security rules can directly verify ownership based on the path, ensuring that a user can only list resources that belong to them. This segregation, using hierarchical paths, simplifies rules and makes them more robust and debuggable."
  }
}